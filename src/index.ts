import { app, BrowserWindow, dialog, ipcMain } from "electron";
import * as fs from "fs/promises";
import * as path from "path";
import PackageInfo from "../package.json";
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 768,
    width: 1280,
    minHeight: 768,
    minWidth: 1280,
    title: `OpenOPL Toolbox - ${PackageInfo.version} [by Luden]`,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

ipcMain.handle("show-open-dialog", async (event, options = {}) => {
  const defaultOptions = {
    properties: ["openDirectory"],
    title: "Select OPL Root Directory",
  };

  const result = await dialog.showOpenDialog({
    ...defaultOptions,
    ...options,
  });

  return result;
});

ipcMain.handle(
  "rename-game",
  async (event, filePath: string, newGameName: string, newGameId: string) => {
    try {
      const originalPath = filePath;
      const directory = path.dirname(originalPath);
      const extension = path.extname(originalPath);
      const newFileName = newGameId
        ? `${newGameId}.${newGameName}${extension}`
        : `${newGameName}${extension}`;
      const newPath = path.join(directory, newFileName);

      await fs.rename(originalPath, newPath);

      return {
        success: true,
        oldPath: originalPath,
        newPath: newPath,
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
      };
    }
  }
);

ipcMain.handle(
  "import-gameart",
  async (event, gameId: string, dirPath: string) => {
    try {
      const items = await fs.readdir(dirPath, { withFileTypes: true });
      const matchingFiles = [];

      for (const item of items) {
        if (item.name.startsWith(".")) {
          continue;
        }

        if (item.isFile() && item.name.includes(gameId)) {
          const filenameParts = item.name.split("_");
          const type =
            filenameParts.length > 2 ? filenameParts.slice(2).join("_") : "";

          matchingFiles.push({
            dir: dirPath,
            filename: item.name,
            type: type.split(".")[0],
          });
        }
      }

      return {
        success: true,
        files: matchingFiles,
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
      };
    }
  }
);

ipcMain.handle(
  "download-gameart",
  async (event, gameId: string, dirPath: string) => {
    // https://raw.githubusercontent.com/Luden02/psx-ps2-opl-art-database/main/PS2/(gameId)/gameId_COV.png
    try {
      const baseUrl =
        "https://raw.githubusercontent.com/Luden02/psx-ps2-opl-art-database/main/PS2";
      const artTypes = [
        "COV",
        "COV2",
        "ICO",
        "LAB",
        "SCR",
        "SCR_00",
        "SCR_01",
        "BG",
      ];
      const downloadedFiles = [];

      for (const artType of artTypes) {
        try {
          const imageUrl = `${baseUrl}/${gameId}/${gameId}_${artType}.png`;
          const response = await fetch(imageUrl);

          if (response.ok) {
            const arrayBuffer = await response.arrayBuffer();
            const imageBuffer = Buffer.from(arrayBuffer);
            const base64 = imageBuffer.toString("base64");

            downloadedFiles.push({
              type: artType,
              data: `data:image/png;base64,${base64}`,
              url: imageUrl,
              filename: `${gameId}_${artType}.png`,
            });
          }
        } catch (error) {
          continue;
        }
      }

      for (const file of downloadedFiles) {
        const filePath = path.join(dirPath, file.filename);
        const base64Data = file.data.replace(/^data:image\/png;base64,/, "");
        const imageBuffer = Buffer.from(base64Data, "base64");
        await fs.writeFile(filePath, imageBuffer);
      }

      return {
        success: true,
        filesDownloaded: downloadedFiles.length,
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
      };
    }
  }
);

ipcMain.handle("get-3d-coverart", async (event, gameId: string) => {
  try {
    // Convert gameId: replace _ with - and remove .
    const formattedGameId = gameId.replace(/_/g, "-").replace(/\./g, "");
    const imageUrl = `https://github.com/xlenore/ps2-covers/raw/main/covers/3d/${formattedGameId}.png`;

    const response = await fetch(imageUrl);

    if (!response.ok) {
      throw new Error(
        `Failed to fetch image: ${response.status} ${response.statusText}`
      );
    }

    const arrayBuffer = await response.arrayBuffer();
    const imageBuffer = Buffer.from(arrayBuffer);
    const base64 = imageBuffer.toString("base64");

    return {
      success: true,
      data: `data:image/png;base64,${base64}`,
      url: imageUrl,
    };
  } catch (error) {
    return {
      success: false,
      error: error.message,
    };
  }
});

ipcMain.handle("read-directory", async (event, dirPath: string) => {
  try {
    const items = await fs.readdir(dirPath, { withFileTypes: true });

    const directories = [];
    const files = [];

    for (const item of items) {
      // Skip files/directories that start with '.'
      if (item.name.startsWith(".")) {
        continue;
      }

      const itemPath = path.join(dirPath, item.name);
      const stats = await fs.stat(itemPath).catch((): null => null);

      const itemInfo = {
        name: item.name,
        path: itemPath,
        isDirectory: item.isDirectory(),
        isFile: item.isFile(),
        size: stats?.size || 0,
        modified: stats?.mtime || new Date(),
      };

      if (item.isDirectory()) {
        directories.push(itemInfo);
      } else {
        files.push(itemInfo);
      }
    }

    return { directories, files };
  } catch (error) {
    throw new Error(`Failed to read directory: ${error.message}`);
  }
});

ipcMain.handle("get-asset", async (event, name: string) => {
  try {
    const assetPath = path.join(__dirname, "../../assets", name);
    const fileBuffer = await fs.readFile(assetPath);
    const base64 = fileBuffer.toString("base64");

    // Determine MIME type based on file extension
    const ext = path.extname(name).toLowerCase();
    const mimeTypes: { [key: string]: string } = {
      ".png": "image/png",
      ".jpg": "image/jpeg",
      ".jpeg": "image/jpeg",
      ".gif": "image/gif",
      ".svg": "image/svg+xml",
      ".webp": "image/webp",
    };

    const mimeType = mimeTypes[ext] || "application/octet-stream";

    return {
      success: true,
      data: `data:${mimeType};base64,${base64}`,
    };
  } catch (error) {
    return {
      success: false,
      error: error.message,
    };
  }
});
